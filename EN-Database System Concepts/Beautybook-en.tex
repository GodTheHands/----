\documentclass{Beautybook-EN}
\coverstyle={cover-choose=en,}
\mathstyle={math-font=mtpro2,}
\usepackage{stys/settings-EN}
\newenvironment{note}[1][\bf Note:]{\par\Line\uuline{#1} }{\par\Line}
\newenvironment{key}[1]{\begin{fancybox}{#1}\ }{\end{fancybox}}
\newcommand{\textcy}[1]{\textbf{\textcolor{cyan}{#1}}}
\newcommand{\textcyi}[1]{\textit{\textcolor{cyan}{#1}}}
\begin{document}
\thispagestyle{empty}
% To Change
\title{Database System Concepts}
\subtitle{Content Overview}
\edition{First Edition}
% End To Change
\bookseries{Content Organization Series}
\author{Zheng Li}
\pressname{E-Book}
\presslogo{inner_pics/Springer-logo.png}
\coverimage{inner_pics/ivy-ge998908f8_1280.jpg}
\makecover
\definecolor{bg}{HTML}{e0e0e0}
\definecolor{fg}{HTML}{203A43}
\colorlet{outermarginbgcolor}{bg}
\colorlet{outermarginfgcolor}{fg}
\colorlet{framegolden}{fg}
\colorlet{framegray}{bg!50}
\colorlet{headlinecolor}{靛蓝}
\chapoddimage{inner_pics/songodd.png}
\chapevenimage{inner_pics/songeven.png}
\oddoutermargin{\cabin\leftmark}
\makeatletter
\evenoutermargin{\cabin\@title}
\setlength\footheight{20pt}
\ofoot{}
\makeatother
\input{frontmatter/titlepage-en}
\frontmatter
\pagenumbering{Roman}
\thispagestyle{empty}
\tableofcontents\let\cleardoublepage\clearpage
\mainmatter
\pagenumbering{arabic}
% To Change
\chapter{Introduction}

A \textcy{database-management system} (\textcy{DBMS}) is a collection of interrelated data and a set of programs to access those data. The collection of data, usually referred to as the \textcy{database}, contains information relevant to an enterprise.

\section{Database-System Applications}

Broadly speaking, there are two modes in which databases are used.
\begin{itemize}
    \item The first mode is to support \textcy{online transaction processing}, where a large number of users use the database, with each user retrieving relatively small amounts of data, and performing small updates.
    \item The second mode is to support \textcy{data analytics}, that is, the processing of data to draw conclusions, and infer rules or decision procedures, which are then userd to drive business decisions.
\end{itemize}

\section{Purpose of Database Systems}

One way to keep the information on a computer is to store it in operating-system files.

This typical \textcy{file-processing system} is supported by a conventional operating system.

Keeping organizational information in a file-processing system has a number of major disadvantages:
\begin{itemize}
    \item\textbf{Data redundancy and inconsistency}. Since different programmers create the files and application programs over a long period, the various files are likely to have different structures, and the programs may be written in several programming languages. Moreover, the same information may be duplicated in several places (files). In addition, it may lead to \textcy{data inconsistency}; that is, the various copies of the same data may no longer agree.
    \item\textbf{Difficulty in accessing data}.
    \item\textbf{Data isolation}.
    \item\textbf{Integrity problems}. The data values stored in the database must satisfy certain types of \textcy{consistency constraints}.
    \item\textbf{Atomicity problems}.
    \item\textbf{Concurrent-access anomalies}.
    \item\textbf{Security problems}.
\end{itemize}

\section{View of Data}
\subsection{Data Models}

Underlying the structure of a database is the \textcy{data model}: a collection of conceptual tools for describing data, data relationships, data semantics, and consistency constraints.

The data models can be classified into four different categories:
\begin{itemize}
    \item\textcy{Relational Model}. The relational model uses a collection of tables to represent both data and the relationships among those data. Each table has multiple columns, and each column has a unique name. Tables are also known as \textcy{relations}.
    \item\textcy{Entity-Relationship Model}.
    \item\textcy{Semi-structured Data Model}.
    \item\textcy{Object-Based Data Model}.
\end{itemize}

\subsection{Data Abstraction}

Since many database-system users are not computer trained, developers hide the complexity from users through several levels of \textcy{data abstraction}, to simplify users' interactions with the system:
\begin{itemize}
    \item\textcy{Physical level}.
    \item\textcy{Logical level}. Although implementation of the simple structures at the logical level may involve complex physical-level structures, the user of the logical level does not need to be aware of this complexity. This is referred to as \textcy{physical data independence}.
    \item\textcy{View level}.
\end{itemize}

\subsection{Instances and Schemas}

The collection of information stored in the database at a particular moment is called an \textcy{instance} of the database. The overall design of the database is called the database \textcy{schema}.

The \textcy{physical schema} describes the database design at the physical level, while the \textcy{logical schema} describes the database design at the logical level. A database may also have several schemas at the view level, sometimes called \textcy{subschemas}, that describe different views of the database.

\section{Database Languages}

A database system provides a \textcy{data-definition langauge} (\textcy{DDL}) to specify the database schema and a \textcy{data-manipulation language} (\textcy{DML}) to express database queries and updates.

\subsection{Data-Definition Language}

We specify the storage structure and access methods used by the database system by a set of statements in a special type of DDL called a \textcy{data storage and definition} language.

In general, a constraint can be an arbitrary predicate pertaining to the database. However, arbitrary predicates may be costly to test. Thus, database systems implement only those integrity constraints that can be tested with minimal overhead:
\begin{itemize}
    \item\textcy{Domain Constraints}.
    \item\textcy{Referential Integrity}.
    \item\textcy{Authorization}. We may want to differentiate among the users as far as the type of access they are permitted on various data values in the database. These differentiations are expressed in terms of \textcy{authorization}, the most common being: \textcy{read authorization}, which allows reading, but not modification, of data; \textcy{insert authorization}, which allows insertion of new data, but not modification of existing data; \textcy{update authorization}, which allows modification, but not deletion, of data; and \textcy{delete authorization}, which allows deletion of data.
\end{itemize}

The output of the DDL is placed in the \textcy{data dictionary}, which contains \textcy{metadata} -- that is, data about data.

\subsection{Data-Manipulation Language}

A \textcy{data-manipulation language} (\textcy{DML}) is a language that enables users to access or manipulate as organized by the appropriate data model. There are basically two types of data-manipulation language:
\begin{itemize}
    \item\textcy{Procedural DMLs} require a user to specify \textit{what} data are needed and \textit{how} to get those data.
    \item\textcy{Declarative DMLs} (also referred to as \textcy{nonprocedural DMLs}) require a user to specify \textit{what} data are needed \textit{without} specifying how to get those data.
\end{itemize}

A \textcy{query} is a statement requesting the retrieval of information. The portion of a DML that involves information retrieval is called a \textcy{query language}.

\subsection{Database Access from Application Programs}

Non-procedural query languages are not as powerful as a universal Turing machine; that is, there are some computations that are possible using a general-purpose programming language but are not possible using SQL. SQL also does not support actions such as input from users, output to displays, or communication over the network. Such computations and actions must be written in a \textit{host} language. \textcy{Application programs} are programs that are used to interact with the database in this fashion.

\section{Database Design}

A high-level data model provides the database designer with a conceptual framework in which to specify the data requirements of the database users and how the database will be structured to fulfill these requirements. The initial phase of database design, then, is to characterize fully the data needs of the prospective database users.

Next, the deisgner chooses a data model, and by applying the concepts of the chosen data model, translates these requirements into a conceptual schema of the database. The schema developed at this \textcy{conceptual-design} phase provides a detailed overview of the enterprise.

In terms of the relational model, the conceptual-design process involves decisions on \textit{what} attributes we want to capture in the database and \textit{how to group} these attributes to form the various tables. The "how" part is mainly a computer-science problem. There are principally two ways to tackle the problem. The first one is to use the entity-relationship model; the other is to employ a set of algorithms (collectively known as \textcy{normalization}) that takes as input the set of all attributes and generates a set of tables.

In a \textcy{specification of functional requirements}, users describe the kinds of operations (or transactions) that will be performed on the data.

In the \textcy{logical-design phase}, the designer maps the high-level conceptual schema onto the implementation data model of the database system that will be used. The designer uses the resulting system-specific database schema in the subsequent \textcy{physical-design phase}, in which the physical features of the database are specified.

\section{Database Engine}

The functional components of a database system can be broadly divided into the storage manager, the \textcy{query processor} components, and the transaction management component.

\subsection{Storage Manager}

The \textcy{storage manager} is the component of a database system that provides the interface between the low-level data stored in the database and the application programs and queries submitted to the system.

The storage manager components include:
\begin{itemize}
    \item\textcy{Authorization and integrity manager}, which tests for the satisfaction of integrity constraints and checks the authority of users to access data.
    \item\textcy{Transaction manager}, which ensures that the database remains in a consistent (correct) state despite system failures, and that concurrent transaction executions proceed without conflicts.
    \item\textcy{File manager}, which manages the allocation of space on disk storage and the data structures used to represent information stored on disk.
    \item\textcy{Buffer manager}, which is responsible for fetching data from disk storage into main memory, and deciding what data to cache in main memory.
\end{itemize}

The storage manager implements several data structures as part of the physical system implementation:
\begin{itemize}
    \item\textcy{Data files}, which store the database itself.
    \item\textcy{Data dictionary}, which stores metadata about the structure of the database, in particular the schema of the database.
    \item\textcy{Indices}, which can provide fast accesss to data items.
\end{itemize}

\subsection{The Query Processor}

The query processor components include:
\begin{itemize}
    \item\textcy{DDL interpreter}, which interprets DDL statements and records the definitions in the data dictionary.
    \item\textcy{DML compiler}, which translates DML statements in a query language into an evaluation plan consisting of low-level instructions that the query-evaluation engine understands.
    
    \quad A query can usually be translated into any of a number of alternative evaluation plans that all give the same result. The DML compiler also performs \textcy{query optimization}; that is, it picks the lowest cost evaluation plan from among the alternatives.
    \item\textcy{Query evaluation engine}, which executes low-level instructions generated by the DML compiler.
\end{itemize}

\subsection{Transaction Management}

Often, several operations on the database form a single logical unit of work. An example is a funds transfer in which one account $A$ is debited and another account $B$ is credited. Clearly, it is essential that either both the credit and debit occur, or that neither occur. This all-or-none requirement is called \textcy{atomicity}. In addition, it is essential that the execution of the funds transfer preserves the consistency of the database. This correctness requirement is called \textcy{consistency}. Finally, after the successful execution of a funds transfer, the new values of the balances of accounts $A$ and $B$ must persist, despite the possibility of system failure. This persistence requirement is called \textcy{durability}.

A \textcy{transaction} is a collection of operations that performs a single logical function in a database application.

Ensuring the atomicity and durability properties is the responsibility of the database system itself -- specifically, of the \textcy{recovery manager}. If we are to ensure the atomicity property, a failed transaction must have no effect on the state of the database. Thus, the database must be restored to the state in which it was before the transaction in question started executing. The database system must therefore perform \textcy{failure recovery}, that is, it must detect system failures and restore the database to the state that existed prior to the occurrence of the failure.

It is the responsibility of the \textcy{concurrency-control manager} to control the interaction among the concurrent transactions, to ensure the consistency of the database. The \textcy{transaction manager} consists of the concurrency-control manager and the recovery manager.

\section{Database and Application Architecture}

Earlier-generation database applications used a \textcy{two-tier architecture}, where the application resides at the client machine, and invokes database system functionality at the server machine through query language statements.

In contrast, modern database applications use a \textcy{three-tier architecture}, where the client machine acts as merely a front end and does not contain any direct database calls; web browsers and mobile applications are the most commonly used application clients today. The front end communicates with an \textcy{application server}. The application server, in turn, communicates with a database system to access data. The \textcy{business logic} of the application, which says what actions to carry out under what conditions, is embedded in the application server, instead of being distributed across multiple clients.

\section{Database Users and Administrators}
\subsection{Database Administrators}

One of the main reasons for using DBMSs is to have central control of both the data and the programs that access those data. A person who has such central control over the system is called a \textcy{database administrators} (\textcy{DBA}).

\section{History of Database Systems}

Techniques for data storage and processing have evolved over the years:
\begin{itemize}
    \item\textbf{1950s and early 1960s}: Magnetic tapes were developed for data storage.
    \item\textbf{Late 1960s and early 1970s}: Widespread use of hard disks in the late 1960s changed the scenario for data processing greatly, since hard disks allowed direct access to data.
    \item\textbf{Late 1970s and 1980s}: Although academically interesting, the relational model was not used in practice initially because of its perceived performance disadvantages; relational databases could not match the performance of existing network and hierarchical databases.
    \item\textbf{1990s}: The SQL language was designed primarily for decision support applications, which are query-intensive, yet the mainstay of databases in the 1980s was transaction-processing applications, which are update-intensive.
    \item\textbf{2000s}: In the latter part of the decade, the use of data analytics and \textcy{data mining} in enterprises became ubiquitous.
    \item\textbf{2010s}: The limitations of NoSQL systems were found acceptable by many applications, in return for the benefits they provided.
\end{itemize}

\chapter{Introduction to the Relational Model}
\section{Structure of Relational Databases}

A relational database consists of a collection of \textcy{tables}, each of which is assigned a unique name.

In mathematical terminology, a \textcyi{tuple} is simply a sequence (or list) of values. A relationship between $n$ values is represented mathematically by an \textcyi{n-tuple} of values, that is, a tuple with $n$ values, which corresponds to a row in a table.

Thus, in the relational model the term \textcy{relation} is used to refer to a table, while the term \textcy{tuple} is used to refer to a row. Similarly, the term \textcy{attribute} refers to a column of a table.

We use the term \textcy{relation instance} to refer to a specific instance of a relation, that is, containing a specific set of rows.

For each attribute of a relation, there is a set of permitted values, called the \textcy{domain} of that attribute.

A domain is \textcy{atomic} if elements of the domain are considered to be indivisible units.

The \textcy{null value} is a special value that signifies that the value is unknown or does not exist.

\section{Database Schema}

When we talk about a database, we must differentiate between the \textcy{database schema}, which is the logical design of the database, and the \textcy{database instance}, which is a snapshot of the data in the database at a given instant in time.

The concept of a relation corresponds to the programming-language notion of a variable, while the concept of a \textcy{relation schema} corresponds to the programming-language notion of type definition.

\section{Keys}

A \textcy{superkey} is a set of one or more attributes that, taken collectively, allow us to identify uniquely a tuple in the relation.

We are often interested in superkeys for which no proper subset is a superkey. Such minimal superkeys are called \textcy{candidate keys}.

We shall use the term \textcy{primary key} to denote a candidate key that is chosen by the database designer as the principal meansof identifying tuples within a relation.

The designation of a key represents a constraint in the real-world enterprise being modeled. Thus, primary keys are also referred to as \textcy{primary key constraints}.

A \textcy{foreign-key constraint} from attribute(s) $A$ of relation $r_1$ to the primary-key $B$ of relation $r_2$ states that on any database instance, the value of $A$ for each tuple in $r_1$ must also be the value of $B$ for some tuple in $r_2$. Attribute set $A$ is called a \textcy{foreign key} from $r_1$, referencing $r_2$. The relation $r_1$ is also called the \textcy{referencing relation} of the foreign-key constraint, and $r_2$ is called the \textcy{referenced relation}.

In general, a \textcy{referential integrity constraint} requires that the values appearing in specified attributes of any typle in the referencing relation also appear in specified attributes of at least one tuple in the referenced relation.

\section{Schema Diagrams}

A database schema, along with primary key and foreign-key constraints, can be depicted by \textcy{schema diagrams}.

\section{Relational Query Languages}

A \textcy{query language} is a language in which a user requests information from the database. In an \textcy{imperative query language}, the user instructs the system to perform a specific sequence of operations on the database to compute the desired result; such languages usually have a notion of state variables, which are updated in the course of the computation.

In a \textcy{functional query language}, the computation is expressed as the evaluation of functions that may operate on data in the database or on the results of other functions; functions are side-effect free, and they do not update the program state.\footnote{The term \textit{procedure language} include functional languages; however, the term is also widely used to refer to imperative languages.} In a \textcy{declarative query language}, the user describes the desired information without giving a specific sequence of steps or function calls for obtaining that information; the desired information is typically described using some form of mathematical logic.

There are a number of "pure" query languages.
\begin{itemize}
    \item The \textit{relational algebra} is a functional query language.
    \item The tuple relational calculus and domain relational calculus are declarative.
\end{itemize}

\section{The Relational Algebra}

The relational algebra consists of a set of operations that take one or two relations as input and produce a new relation as their result.

Some of these operations are called \textit{unary} operations because they operate on one relation. The other operations operate on pairs of relations and are, therefore, called \textit{binary} operations.

\subsection{The Select Operation}

The \textcy{select} operation selects tuples that satisfy a given predicate.

\subsection{The Project Operation}

Suppose we want to list all instructors' \textit{ID}, \textit{name}, and \textit{salary}, but we do not care about the \textit{dept\_name}. The \textcy{project} operation allows us to produce this relation.

\subsection{Composition of Relational Operations}

In general, since the result of a relational-algebra operation is of the same type (relation) as its inputs, relational-algebra operations can be composed together into a \textcy{relational-algebra expression}.

\subsection{The Cartesian-Product Operation}

The \textcy{Cartesian-product} operation, denoted by a cross ($\times$), allows us to combine information from any two relations.

\subsection{The Join Operation}

Consider relations $r(R)$ and $s(S)$, and let $\theta$ be a predicate on attributes in the schema $R\cup S$. The \textcy{join} operation $r\Join_{\theta}s$ is defined as follows: $$r\Join_{\theta}s=\sigma_{\theta}(r\times s)$$

\subsection{Set Operations}

In general, for a union operation to make sense:
\begin{enumerate}
    \item We must ensure that the input relations to the union operation have the same number of attributes; the number of attributes of a relation is referred to as its \textcy{arity}.
    \item When the attributes have associated types, the types of the $i$th attributes of both input relations must be the same, for each $i$.
\end{enumerate}
Such relations are referred to as \textcy{compatible} relations.

The \textcy{intersection} operation, denote by $\cap$, allows us to find tuples that are in both the input relations.

The \textcy{set-difference} operation, denoted by $-$, allows us to find tuples that are in one relation but are not in another.

\subsection{The Assignment Operation}

The \textcy{assignment} operation, denoted by $\leftarrow$, works like assignment in a programming language.

\subsection{The Rename Operation}

Unlike relations in the database, the results of relational-algebra expressions do not have a name that we can use to refer to them. It is useful in some cases to give them names; the \textcy{rename} operator, denoted by the lowercase Greek letter rho ($\rho$), lets us to this.

\chapter{Introduction to SQL}
\section{Overview of the SQL Query Language}

The SQL language has several parts:
\begin{itemize}
    \item\textcy{Data-definition language} (\textcy{DDL}).
    \item\textcy{Data-manipulation language} (\textcy{DML}).
    \item\textbf{Integrity}.
    \item\textbf{View definition}.
    \item\textbf{Transaction control}.
    \item\textbf{Embedded SQL} and \textbf{dynamic SQL}.
    \item\textbf{Authorization}.
\end{itemize}

\section{SQL Data Definition}
\subsection{Basic Types}

The SQL standard supports a variety of built-in types, including:
\begin{itemize}
    \item\textbf{char}$(n)$: A fixed length character string with user-specified length $n$.
    \item\textbf{varchar}$(n)$: A variable-length character string with user-specified maximum length $n$.
    \item\textbf{int}: An integer (a finite subset of the integers that is machine dependent).
    \item\textbf{smallint}: A small integer (a machine-dependent subset of the integer type).
    \item\textbf{numeric}$(p,d)$: A fixed-point number with user-specified precision.
    \item\textbf{real, double precision}: Floating-point and double-precision floating-point numbers with machine-dependent precision.
    \item\textbf{float}$(n)$: A floating-point number with precision of at least $n$ digits.
\end{itemize}

Each type may include a special value called the \textcy{null} value.

\subsection{Basic Schema Definition}

SQL supports a number of different integrity constraints. In this section, we discuss only a few of them:
\begin{itemize}
    \item\textbf{primary key} $(A_{j_1},A_{j_2},\ldots,A_{j_m})$: The \textcy{primary-key} specification says that attributes $A_{j_1},A_{j_2},\ldots,A_{j_m}$ form the primary key for the relation.
    \item\textbf{foreign key} $(A_{k_1},A_{k_2},\ldots,A_{k_n})$ \textbf{references} $s$: The \textbf{foreign key} specification says that the values of attributes $(A_{k_1},A_{k_2},\ldots,A_{k_n})$ for any tuple in the relation must correspond to values of the primary key attributes of some tuple in relation $s$.
    \item\textbf{not null}: The \textbf{not null} constraint on an attribute specifies that the null value is not allowed for that attribute; in other wrods, the constraint excludes the null value from the domain of that attribute.
\end{itemize}

\section{Basic Structure of SQL Queries}

The basic structure of an SQL query consists of three clauses: \textcy{select}, \textcy{from}, and \textcy{where}.

\section{Additional Basic Operations}
\subsection{The Rename Operation}

Consider the query:
\begin{center}
    \begin{tabular}{l}
        \textbf{select} \textit{name}, \textit{course\_id}\\
        \textbf{from} \textit{instructor}, \textit{teaches}\\
        \textbf{where} \textit{instructor.ID = teaches.ID}
    \end{tabular}
\end{center}
The result of this query is a relation with the following attributes:
\begin{center}
    \textit{name}, \textit{course\_id}
\end{center}
The names of the attributes in the result are derived from the names of the attributes in the relations in the \textbf{from} clause.

We cannot, however, always derive names in this way, for several reasons: First, two relations in the \textbf{from} clause may have attributes with the same name, in which case an attribute name is duplicated in the result. Second, if we use an arithmetic expression in the \textbf{select} clause, the resultant attribute does not have a name. Third, even if an attribute name can be derived from the base relations, we may want to change the attribute name in the result. Hence, SQL provides a way of renaming the attributes of a result relation. It uses the \textcy{as clause}, taking the form:
\begin{center}
    \textit{old}-\textit{name} \textbf{as} \textit{new}-\textit{name}
\end{center}
The \textbf{as} clause can appear in both the \textbf{select} and \textbf{from} clauses.\footnote{Early versions of SQL did not include the keyword \textbf{as}. As a result, some implementations of SQL do not permit the keyword \textbf{as} in the \textcy{from} clause.}

\begin{fancybox}
    \begin{center}
        {\textbf{SQL AND MULTISET RELATIONAL ALGEBRA - PART 1}}
    \end{center}

    The SQL standard defines how many copies of each tuple are there in the output of a query, which depends, in turn, on how many copies of tuples are present in the input relations.

    To model this behavior of SQL, a version of relational algebra, called the \textcy{multiset relational algebra}, is defined to work on multisets: sets that may contain duplicates.
\end{fancybox}

An identifier that is used to rename a relation is referred to as a \textcy{correlation name} in the SQL standard, but it is also commonly referred to as a \textcy{table alias}, or a \textcy{correlation variable}, or a \textcy{tuple variable}.

\subsection{Ordering the Display of Tuples}

The \textcy{order by} clause causes the tuples in the result of a query to appear in sorted order.

\section{Set Operations}

% End To Change
{ % 限制空页面样式命令作用范围
\normalem
\thispagestyle{empty}}
\bottomimage{inner_pics/ivy-ge998908f8_1280.jpg}
\summary{Learning is all you need}
\makebottomcover
\end{document} 